# 算法原理

A* (A-star) 算法是图搜索算法中最著名和最成功的算法之一。它通常用于**寻路**和 **图遍历** ，尤其是在有明确目标的情况下，它比 Dijkstra 算法更高效。

## 核心思想：评估函数 **$f(n)$**

A* 算法通过引入一个**启发式函数（Heuristic Function）**来指导搜索方向，使其优先搜索靠近目标的节点，从而避免像 Dijkstra 那样“盲目”地向各个方向扩展。

A* 算法在选择下一个要探索的节点 **$n$** 时，依据一个**评估函数 **$f(n)$**** 的最小值：

$$
f(n) = g(n) + h(n)
$$

| **组成部分** | **含义**                        | **解释 (与 Dijkstra 区别)**                                                                                                           |
| ------------------ | ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| **$g(n)$** | **实际成本 (Actual Cost)**      | 从**起点**到当前节点**$n$**的 **实际最短路径成本** 。**这部分与 Dijkstra 算法的**$\text{dist}[n]$**完全相同。** |
| **$h(n)$** | **启发式成本 (Heuristic Cost)** | 从当前节点**$n$**到**目标点**的 **估计成本** 。这个估计值必须是 **可接受的 (Admissible)** 。                            |
| **$f(n)$** | **总评估成本 (Total Cost)**     | 从**起点**经过**$n$**到达**目标点**的 **总估计成本** 。算法总是优先选择**$f(n)$**最小的节点。                   |

## 常见启发式函数

在网格地图（如游戏或机器人路径规划）中，最常用的启发式函数是：

* 曼哈顿距离 (Manhattan Distance)：用于允许四个方向移动的网格图。
  $$
  h(n) = |x_n - x_{\text{目标}}| + |y_n - y_{\text{目标}}|
  $$
* 欧几里得距离 (Euclidean Distance)：用于允许八个方向移动的网格图。
  $$
  h(n) = \sqrt{(x_n - x_{\text{目标}})^2 + (y_n - y_{\text{目标}})^2}
  $$

# 算法步骤总结

A* 算法的步骤与 Dijkstra 非常相似，主要区别在于优先队列中存储和比较的值：

1. **初始化** ：使用两个列表/集合，`OpenList`（相当于 Dijkstra 的优先队列，存储待访问节点）和 `ClosedList`（存储已访问节点）。
2. **设置** ：

* **$\text{g\_score}[n]$** 存储 **$g(n)$**，初始化起点 **$\text{g\_score}[\text{start}] = 0$**，其他为 **$\infty$**。
* **$\text{f\_score}[n]$** 存储 **$f(n)$**，初始化 **$\text{f\_score}[\text{start}] = h(\text{start})$**，其他为 **$\infty$**。
* 将 **$\langle f(\text{start}), \text{start} \rangle$** 压入优先队列 (`OpenList`)。

3. **循环** ：当 `OpenList` 不为空时：

* 从 `OpenList` 中取出 **$f(n)$** 最小的节点 **$u$**。
* 如果 **$u$** 是目标点，则停止并重建路径。
* 对于 **$u$** 的每个邻居 **$v$**：
  * 计算通过 **$u$** 到达 **$v$** 的新 **$g$** 值：**$\text{new\_g} = \text{g\_score}[u] + \text{weight}(u, v)$**。
  * **松弛** ：如果 **$\text{new\_g} < \text{g\_score}[v]$**：
  * 更新 **$\text{g\_score}[v] = \text{new\_g}$**。
  * 更新 **$\text{f\_score}[v] = \text{g\_score}[v] + h(v)$**。
  * 记录前驱 **$\text{parent}[v] = u$**。
  * 将 **$\langle f(v), v \rangle$** 压入 `OpenList`。

# 复杂度

## 时间复杂度


$$
\text{最坏时间复杂度} = O((V + E) \log V)
$$


**然而，A* 的实际性能优势体现在其平均/最佳时间复杂度上：**

* **平均耗时：** 当启发式函数 **$h(n)$** 优秀且具有指导性时，A* 算法只会搜索地图的一小部分（靠近目标点的区域），而不是像 Dijkstra 那样均匀地向外扩展。
  * **搜索节点数 **$V'$**:** 实际探索的节点数 **$V'$** 远小于总节点数 **$V$**。
  * **实际复杂度：** 在许多实际应用中，A* 的表现更接近于 **$O(V' \log V')$**，其中 **$V'$** 是算法实际遍历的节点数。
  * **当 **$h(n)$** 非常准确时（例如 **$h(n)$** 等于实际最短距离）：** A* 的搜索可以非常接近线性时间 **$O(V')$**.


## 空间复杂度


| **数据结构**             | **空间占用**                   | **作用**                                                                                      |
| ------------------------------ | ------------------------------------ | --------------------------------------------------------------------------------------------------- |
| **节点数组 (`nodes`)** | **$O(V)$**                   | 存储所有节点的状态（**$g\_score, f\_score, \text{parent}, x, y$**）。这是最主要的内存占用。 |
| **优先队列 (`pq`)**    | 最坏**$O(V)$**或**$O(E)$** | 存储待探索的节点。最坏情况下与边的数量**$E$**成正比，但在稀疏网格图中为**$O(V)$**。       |
| **输入地图 (`map`)**   | **$O(V)$**                   | 存储网格障碍物信息。                                                                                |

**总空间复杂度**为：

$$
O(V)
$$

# 优缺点总结


### ✅ 优点 (Advantages)

1. **效率极高（定向搜索）** ：这是 A* 相较于 Dijkstra 最大的优势。通过使用启发式函数 **$h(n)$**，A* 能够将搜索重点放在接近目标点的区域，从而避免探索大量无关节点，大大节省了计算时间。
2. **保证最优解（完备性）** ：只要使用的启发式函数 **$h(n)$** 是 **可接受的 (Admissible)** （即永不夸大实际成本），A* 就能保证找到最短路径。
3. **适应性强** ：可以通过调整启发式函数来平衡搜索速度和最优性：

* **提高 **$h(n)$** 精度** ：搜索速度更快，但需确保仍是可接受的。
* **$h(n) = 0$** ：退化为 Dijkstra，保证最优但速度慢。

1. **应用广泛** ：它是游戏寻路、机器人导航、物流规划等许多领域中最常用的算法。

### ❌ 缺点 (Disadvantages)

1. **内存消耗大** ：A* 必须存储所有已访问节点的信息（在您的代码中是整个 **$R \times C$** 的 `nodes` 数组），以便进行松弛操作和路径重建。对于非常大的地图或图，内存限制可能是一个问题。

* *Dijkstra 也需要存储所有节点的 `dist`，但 A* 对内存的压力通常更大，因为它需要存储更多的状态信息。*

1. **依赖启发式函数** ：A* 的效率和正确性**强烈依赖**于启发式函数的质量：

* **$h(n)$ 不可接受** ：如果启发式函数夸大了实际成本，A* 算法可能无法保证找到最短路径。
* **$h(n)$ 太小** ：如果启发式函数太小（接近 0），A* 的性能会接近 Dijkstra，失去定向搜索的优势。

1. **无法处理负权边** ：与 Dijkstra 算法一样，A* 算法的贪心策略依赖于边的非负权。如果图中有负权边，A* 算法会失效。
