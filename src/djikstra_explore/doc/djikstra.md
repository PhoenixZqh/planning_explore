# 核心思想

**1. 初始化：** 维护一个集合，记录已找到最短路径的节点，以及一个距离数组，记录从起点到每个节点的当前最短距离。起点到自身的距离设为 0，到其他所有节点的距离设为无穷大（**$\infty$**）。

**2. 迭代：** 重复以下步骤，直到所有节点都被访问或目标节点被访问：

* 从**尚未确定最短路径的节点**中，选择一个**当前距离起点最近**的节点 **$u$**。
* 将节点 **$u$** 标记为“已确定最短路径”。
* 松弛操作 (Relaxation)： 遍历 $u$ 的所有邻接点 $v$。如果通过 $u$ 到达 $v$ 的距离更短，则更新 $v$ 的最短距离。
  $$
  \text{dist}[v] = \min(\text{dist}[v], \text{dist}[u] + \text{weight}(u, v))
  $$
* 为了记录路径，通常还需要一个**前驱（`parent`）数组**来记录到达 **$v$** 的最短路径上的前一个节点。

# 算法原理

## 初始化

1. 距离数组 **$\text{dist}[]$**，初始化 **$\text{dist}[\text{start}] = 0$**，其余为 **$\infty$**
2. 前驱数组 **$\text{parent}[]$**，用于路径重建, 保存的是上一个节点
3. 优先队列 **$PQ$**，存储 **$\langle \text{距离}, \text{节点ID} \rangle$**，初始将 **$\langle 0, \text{start} \rangle$** 压入

## 循环

* 从 **$PQ$** 中取出距离最小的节点 **$u$**（及其距离 **$d$**）。
* **剪枝/优化** ：如果 **$d > \text{dist}[u]$**，说明 **$u$** 已经被更短的路径更新过，跳过本次循环。
* **松弛** ：对于 **$u$** 的每个邻居 **$v$**（边权为 **$w$**）：
* 如果 **$\text{dist}[u] + w < \text{dist}[v]$**：
  * 更新 **$\text{dist}[v] = \text{dist}[u] + w$**。
  * 设置 **$\text{parent}[v] = u$**。
  * 将 **$\langle \text{dist}[v], v \rangle$** 压入 **$PQ$**。


# 复杂度计算

时间复杂度：

| **操作**                        | **执行次数**                  | **单次耗时（优先队列）** | **总耗时**          |
| ------------------------------------- | ----------------------------------- | ------------------------------ | ------------------------- |
| **取出最小元素 (`pq.pop()`)** | **$V$**次（每个节点最多出队一次） | **$O(\log V)$**        | **$O(V \log V)$** |
| **松弛操作 (`pq.push()`)**    | **$E$**次（每条边最多检查一次）   | **$O(\log V)$**        | **$O(E \log V)$** |

空间复杂度：

| **数据结构**              | **空间占用**     | **作用**                                                                                                       |
| ------------------------------- | ---------------------- | -------------------------------------------------------------------------------------------------------------------- |
| **邻接表 (`Graph`)**    | **$O(V + E)$** | 存储图结构（**$V$**个节点列表，共**$E$**条边记录）。                                                       |
| **距离数组 (`dist`)**   | **$O(V)$**     | 存储从起点到所有节点的当前最短距离。                                                                                 |
| **前驱数组 (`parent`)** | **$O(V)$**     | 用于路径重建。                                                                                                       |
| **优先队列 (`pq`)**     | 最坏**$O(E)$**       | 最坏情况下，每条边松弛操作都会导致一个元素入队，虽然许多可能是重复的。实际上，在任何时刻，其大小通常远小于**$E$**. |

# 优缺点


## ✅ 优点 (Advantages)

1. **全局最优解** ：能够保证找到从起点到**所有其他可达节点**的 **最短路径** ，结果是绝对准确的。
2. **效率高** ：在边的权重为非负数的情况下，优先队列优化的 Dijkstra 算法 **$O((V+E)\log V)$** 效率非常高，适用于大型稀疏图。
3. **算法简单清晰** ：核心思想是贪心策略和松弛操作，概念相对容易理解和实现。
4. **应用广泛** ：是 GPS 导航、网络路由协议（如 OSPF）等许多实际应用的基础。

## ❌ 缺点 (Disadvantages)

1. **无法处理负权边** ：这是 Dijkstra 算法最主要的限制。如果图中有 **负权边** ，Dijkstra 算法的贪心策略就会失效，无法保证找到最短路径。

* *替代方案：* 如果存在负权边，必须使用 **Bellman-Ford 算法** (**$O(VE)$**) 或  **SPFA 算法** （在实际应用中通常很快，但最坏情况是 **$O(VE)$**）。

1. **单源计算** ：它只能解决**单源最短路径**问题（从一个起点到所有其他点）。如果需要找到所有节点对之间的最短路径，需要运行 **$V$** 次 Dijkstra，总复杂度变为 **$O(V(V+E)\log V)$**。

* *替代方案：* 所有对最短路径问题通常使用 **Floyd-Warshall 算法** (**$O(V^3)$**)。

1. **计算范围大** ：即使您只需要从 **$A$** 到 **$B$** 的路径，Dijkstra 算法在最坏情况下也可能需要探索图中的大部分区域，因为它本质上是计算从 **$A$** 到**所有**点的最短路径。

* *替代方案：* 带有启发式搜索的  **A* 算法** ，在知道目标位置的情况下，可以更快地收敛到终点。
